# 참조에 의한 객체 복사

객체와 원시 타입의 근본적인 차이 중 하나는 객체는 ‘참조에 의해(by reference)’ 저장되고 복사된다는 것입니다.

## 참조 복사
```js
let user = { name: 'John' };

let clone = user; // 참조값을 복사함

clone.name = 'Pete'; // 'clone' 참조 값에 의해 변경됨

alert(user.name); // 'Pete'가 출력됨. 'user' 참조 값을 이용해 변경사항을 확인함
```
복사본의 프로퍼티(키 또는 값)을 바꾸면 원본의 프로퍼티도 바뀐다 ! (영향을 준다.)

위 예제에서 복사본(clone)의 프로퍼티 값을 변경하면 원본(user)의 프로퍼티 값도 변경하는 것을 볼 수 있다.


## 얕은 복사 (shallow copy)
```js
let user = { name: "John" };

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```
복사본의 프로퍼티를 바꿔도 원본의 프로퍼티는 바뀌지 않는다 ! (복사본과 원본은 독립적이다)

하지만 완벽히 독립적이라고 말하기는 어렵다. 중첩 객체(객체 내 객체)는 독립적이지 않다.


## 깊은 복사 (deep copy/cloning)
```js
let user = { name: "John", private: { age: 30 } };

const _ = require('lodash');
const clone = _.cloneDeep(user);

clone.private.age = 20;

alert( user.private.name ); // 중첩 객체는 독립적이므로 기존값인 30이 유지된다 ! (얕은 복사는 20이 나온다.)
```
복사본의 프로퍼티를 바꿔도 원본의 프로퍼티는 바뀌지 않는다.
중첩 객체도 원본과 복사본이 독립적이다 !

위클리 페이퍼 3주차에 다룬 내용이어서
제 노션을 참고하면 도움이 될 것 같습니다 !
https://www.notion.so/266e0134ee5480eea3fdc9b1799f2134 

# 옵셔널 체이닝
옵셔널 체이닝(optional chaining) `?.`을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근할 수 있습니다.

?.은 ?.'앞’의 평가 대상이 `undefined`나 `null`이면 평가를 멈추고 `undefined`를 반환합니다.

꼭 있어야 하는 값인데 없는 경우에 `?.`을 사용하면 프로그래밍 에러를 쉽게 찾을 수 없으므로 이런 상황을 만들지 말도록 합시다.
```js
let user = {};

alert( user?.address ); // undefined
alert( user?.address.street ); // Error
```

PART1 멘토링 中

옵셔널 체이닝의 장단점은?
user?.profile?.email
객체가 깊어질수록 

장점: (a && a.b && a.b.c)에서 (a?.b?.c)로 간결하게 처리할 수 있다.

단점: 중간에 어떤 값이 undefined인지 확인하기 어렵다.
