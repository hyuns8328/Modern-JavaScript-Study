# 참조에 의한 객체 복사

객체의 변수에는 객체가 그대로 저장되는 것이 아니라, 객체가 저장되어 이는 '메모리 주소'인 객체에 대한 '참조 값'이 저장됩니다.
```js
let user = {
  name: 'John',
}

// 변수는 두 개이지만 각 변수에는 동일 객체에 대한 참조 값이 저장됩니다.
let admin = user; // 참조값을 복사함


let user = { name: 'John' };
let admin = user;
admin.name = 'Pete'; // 'admin' 참조 값에 의해 변경됨
alert(user.name); // 'Pete'가 출력됨. 'user' 참조 값을 이용해 변경사항을 확인
```


## 참조에 의한 비교
```js
let a = {};
let b = a; // 참조에 의한 복사

alert( a == b ); // true, 두 변수는 같은 객체를 참조합니다.
alert( a === b ); // true

// 두 객체 모두 비어 있다는 점에서 같아보이지만
// 독립된 객체이기 때문에 일치,동등 비교시에 거짓이 반환됩니다.
let a = {};
let b = {}; // 독립된 두 객체

alert( a == b ); // false
```

## 객체 복사, 병합과 Object.assign

```js
// 객체를 복사하고 싶을 때 사용하는 방
let user = {
  name: "John",
  age: 30
};

let clone = {}; // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣습니다.
for (let key in user) {
  clone[key] = user[key];
}

// 이제 clone은 완전히 독립적인 복제본이 되었습니다.
clone.name = "Pete"; // clone의 데이터를 변경합니다.

alert( user.name ); // 기존 객체에는 여전히 John이 있습니다.
```

//
```js
// 깊은 복사
// 객체 안의 객체까지 복사가 가능하다.
let user = {
  name: "John",
  sizes: {
    height: 182,
    width: 50
  }
};

let clone = Object.assign({}, user);

alert( user.sizes === clone.sizes ); // true, 같은 객체입니다.

// user와 clone는 sizes를 공유합니다.
user.sizes.width++;       // 한 객체에서 프로퍼티를 변경합니다.
alert(clone.sizes.width); // 51, 다른 객체에서 변경 사항을 확인할 수 있습니다.
```

lodash 사용 예제
```js
import cloneDeep from 'lodash/cloneDeep';

const original = {
  user: {
    name: '철수',
    age: 25,
    skills: ['JS', 'React']
  }
};

// 얕은 복사 (spread 연산자)
const shallowCopy = { ...original };

// 깊은 복사 (cloneDeep)
const deepCopy = cloneDeep(original);

// 값 변경
shallowCopy.user.name = '영희';
deepCopy.user.skills.push('Node.js');

console.log('원본:', original);
console.log('얕은 복사:', shallowCopy);
console.log('깊은 복사:', deepCopy);

원본: { user: { name: '영희', age: 25, skills: [ 'JS', 'React' ] } }
얕은 복사: { user: { name: '영희', age: 25, skills: [ 'JS', 'React' ] } }
깊은 복사: { user: { name: '철수', age: 25, skills: [ 'JS', 'React', 'Node.js' ] } }
```

객체의 '진짜 복사본’을 만들려면 
'얕은 복사(shallow copy)'를 가능하게 해주는 Object.assign이나 
'깊은 복사’를 가능하게 해주는 _.cloneDeep(obj)를 사용하면 됩니다. 

# 옵셔널 체이닝 '?.'
?.은 ?.'앞’의 평가 대상이 undefined나 null이면 평가를 멈추고 undefined를 반환합니다.

## 단락 평가
?.는 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춥니다. 참고로 이런 평가 방법을 단락 평가(short-circuit)라고 부릅니다.
```js
let user = null;
let x = 0;

user?.sayHi(x++); // 아무 일도 일어나지 않습니다.

alert(x); // 0, x는 증가하지 않습니다.
```


```js
// 옵셔널 체이닝 활용 방법
// user가 존재하면 삭제
delete user?.name;

// 활용방법 2
let user = null;
console.log(user?.profile);        // undefined
console.log(user?.profile?.name);  // undefined

// ??는 왼쪽의 값이 null이거나 undifined면 출력
console.log(user?.profile?.name ?? "손님"); // "손님"
```


