# 배열과 메서드

## 요소를 더하거나 지우기
`push(...items)` – 맨 끝에 요소 추가하기
`pop()` – 맨 끝 요소 추출하기
`shift()` – 첫 요소 추출하기
`unshift(...items)` – 맨 앞에 요소 추가하기
`splice(pos, deleteCount, ...items)` – pos부터 deleteCount개의 요소를 지우고, items 추가하기
`slice(start, end)` – start부터 end 바로 앞까지의 요소를 복사해 새로운 배열을 만듦
`concat(...items)` – 배열의 모든 요소를 복사하고 items를 추가해 새로운 배열을 만든 후 이를 반환함. items가 배열이면 이 배열의 인수를 기존 배열에 더해줌

## 원하는 요소 찾기
`indexOf/lastIndexOf(item, pos)` – pos부터 원하는 item을 찾음. 찾게 되면 해당 요소의 인덱스를, 아니면 -1을 반환함
`includes(value)` – 배열에 value가 있으면 true를, 그렇지 않으면 false를 반환함
`find/filter(func)` – func의 반환 값을 true로 만드는 첫 번째/전체 요소를 반환함
`findIndex`는 find와 유사함. 다만 요소 대신 인덱스를 반환함

## 배열 전체 순회하기
`forEach(func)` – 모든 요소에 func을 호출함. 결과는 반환되지 않음

## 배열 변형하기
`map(func)` – 모든 요소에 func을 호출하고, 반환된 결과를 가지고 새로운 배열을 만듦
`sort(func)` – 배열을 정렬하고 정렬된 배열을 반환함 / 내림차순 `sort((a, b) => a - b);`
`reverse()` – 배열을 뒤집어 반환함
`split/join` – 문자열을 배열로, 배열을 문자열로 변환함
`reduce(func, initial)` – 요소를 차례로 돌면서 func을 호출함. 반환값은 다음 함수 호출에 전달함. 최종적으로 하나의 값이 도출됨

## 그 외
`arr.some(fn)` - 반환 값을 true로 만드는 요소가 하나라도 있는지 여부 확인
`arr.every(fn)` - 모든 요소가 반환 값을 true로 만드는지 여부 확인
`arr.fill(value, start, end)` - start부터 end까지 value를 채워 넣습니다.
`arr.copyWithin(target, start, end)` - start부터 end까지 요소를 복사하고, 복사한 요소를 target에 붙여넣습니다. 기존 요소가 있다면 덮어씁니다.

(item, index, array)
`forEach`, `find`, `filter`, `map`

(acc, item, index, array)
`reduce`

## 배열 메서드와 'thisArg'
함수를 호출하는 대부분의 배열 메서드(find, filter, map 등. sort는 제외)는 thisArg라는 매개변수를 옵션으로 받을 수 있습니다.
```js
let army = {
  minAge: 18,
  maxAge: 27,
  canJoin(user) {
    return user.age >= this.minAge && user.age < this.maxAge;
  }
};

let users = [
  {age: 16},
  {age: 20},
  {age: 23},
  {age: 30}
];

// army.canJoin 호출 시 참을 반환해주는 user를 찾음
let soldiers = users.filter(army.canJoin, army);

alert(soldiers.length); // 2
alert(soldiers[0].age); // 20
alert(soldiers[1].age); // 23
```
thisArgs에 army를 지정하지 않고 단순히
users.filter(army.canJoin)를 사용했다면 army.canJoin은 단독 함
수처럼 취급되고, 함수 본문 내 this는 undefined가 되어 에러가 발생했을
 겁니다.

users.filter(user => army.canJoin(user))를 사용하면
users.filter(army.canJoin, army)를 대체할 수 있긴 한데 thisArg
를 사용하는 방식이 좀 더 이해하기 쉬우므로 더 자주 사용됩니다.
