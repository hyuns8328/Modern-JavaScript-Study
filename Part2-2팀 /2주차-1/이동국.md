# if와 '?'를 사용한 조건 처리

## falsy 값
`0`, `""`, `null`, `undefined`, `NaN`

## 조건부 연산자
```js
let result = condition ? value1 : value2;
```
자바스크립트에서 피연산자를 3개나 받는 연산자는 조건부(conditional) 연산자 (삼항(ternary) 연산자)가 유일하다 !
조건부 연산자는 표현식, if ... else는 문이다 !

## 표현식(expression)과 문(statement) 차이점
표현식: 값을 만들어내는 코드 조각
```js
1 + 2        // → 3
"Hello"      // → "Hello"
num * 5      // → 어떤 값
condition ? "A" : "B" // → "A" 또는 "B"
```
문: 행동을 지시하는 코드 (값 반환 X)
```js
if (x > 10) { ... }
for (let i = 0; i < 5; i++) { ... }
let y = 5;
```

# 객체
key: value // property
```js
let user = new Object(); // '객체 생성자' 문법
let user = {};  // '객체 리터럴' 문법
```
삭제: `delete`

'점’은 키가 '유효한 변수 식별자’인 경우에만 사용할 수 있습니다. 유효한 변수 식별자엔 공백이 없어야 합니다. 또한 숫자로 시작하지 않아야 하며 $와 _를 제외한 특수 문자가 없어야 합니다.

'대괄호'는 동적 키로 접근 가능

## 계산된 프로퍼티
```js
let fruit = prompt("어떤 과일을 구매하시겠습니까?", "apple");

let bag = {
  [fruit]: 5, // 변수 fruit에서 프로퍼티 이름을 동적으로 받아 옵니다.
};

alert( bag.apple ); // fruit에 "apple"이 할당되었다면, 5가 출력됩니다.
```
### 배열에서는 `for...in` 사용이 비추천인 이유 ?
모든 열거 가능한 속성을 가져오면서 예상치 못한 값이 포함될 수 있다 !
```js
arr.custom = 99;

Array.prototype.extra = "x";
```

### 객체에서는 `for...of` 불가능 !
for…of는 이터러블(iterable) 객체를 순회할 때 사용됩니다.
**일반 객체({})**는 이터러블이 아니므로, 바로 for…of obj 하면 **오류(TypeError)**가 발생합니다.

# 원시값의 메서드
원시값이 메서드나 프로퍼티에 접근하려 하면 추가 기능을 제공해주는 특수한 객체, "원시 래퍼 객체(object wrapper)"를 만들어 줍니다. 이 객체는 곧 삭제됩니다.
"래퍼 객체"는 원시 타입에 따라 종류가 다양합니다. 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String`,`Number`,`Boolean`, `Symbol`라고 부릅니다. 래퍼 객체 마다 제공하는 메서드 역시 다릅니다.

자바스크립트 엔진은 위 프로세스의 최적화에 많은 신경을 씁니다. 원시 래퍼 객체를 만들지 않고도 마치 원시 래퍼 객체를 생성(명세에 언급됨)한 것처럼 동작하게끔 해주죠.

## 엄격 모드란 ?
ES5 이후 도입된 자바스크립트 실행 모드
안정성 향상을 위해 JS 실행 시 오류와 잘못된 동작을 엄격히 체크 
| 구분            | 일반 모드 | 엄격 모드               |
| ------------- | ----- | ------------------- |
| 변수 선언 없이 사용   | 허용    | 금지 (ReferenceError) |
| 읽기 전용 프로퍼티 수정 | 무시    | TypeError           |
| 중복 매개변수       | 허용    | SyntaxError         |
| `this` 바인딩    | 전역 객체 | undefined (함수 내부)   |

## 객체처럼 고유한 프로퍼티와 메소드를 사용하면 시스템 자원이 왜 많이 소모될까 ?
Javascript에서 객체는 **키와 값의 쌍, 그리고 메소드**를 담는 **동적 해시 테이블 구조**이다.
즉, 객체가 많아질수록 증가:
* 프로퍼티별 메모리
* 함수 객체별 메모리
* 내부 해시 테이블 구조 관리

시스템 자원 소모 요약
1. 메모리
* 객체가 많을수록 프로퍼티, 메소드별 메모리 사용 증가
* 메소드가 객체마다 별도로 정의되면 중복 메모리

2. CPU
* 프로퍼티/메소드 접근 시 해시 테이블 검색
* 동적 바인딩, 상속 체인 탐색
* 함수 호출 비용

3. 가비지 컬렉션(GC) 부담
* 동적으로 생성된 많은 객체/함수 → GC가 자주 실행 → CPU 부담 증가

## 가비지 컬렉션(GC)란?
* 메모리 관리 자동화 기능
* 더 이상 참조되지 않는 객체를 찾아서 메모리에서 제거(메모리 누수 방지)
* 개발자가 직접 메모리를 해제할 필요 없음

## 객체 생성자와 객체 리터럴의 차이점은?
| 구분     | 객체 생성자     | 객체 리터럴              |
| ------ | ---------------- | ------------------- |
| 생성 방식  | 함수 호출            | 바로 정의               |
| 프로토타입  | 생성자 함수 프로토타입 연결  | Object.prototype 연결 |
| 메소드 공유 | 프로토타입에 올리면 공유 가능 | 각 객체마다 생성 → 공유 X    |
| 상속/클래스 | 가능               | 제한적                 |
| 사용 용도  | 반복 생성, 상속 구조     | 한 번만 쓰는 단순 객체       |

