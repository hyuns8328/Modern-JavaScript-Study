#   배열과 메서드

### 요소 추가 제거 메서드
arr.push(...items) – 맨 끝에 요소 추가
arr.pop() – 맨 끝 요소 제거
arr.shift() – 맨 앞 요소 제거
arr.unshift(...items) – 맨 앞에 요소 추가

### splice 문법
arr.splice(index[, deleteCount, elem1, ..., elemN])
첫 번째 매개변수는 조작을 가할 첫 번째 요소를 가리키는 인덱스(index)입니다. 
두 번째 매개변수는 deleteCount로, 제거하고자 하는 요소의 개수를 나타냅니다. 
elem1, ..., elemN은 배열에 추가할 요소를 나타냅니다.

delete 사용시 배열의 길이는 그대로, undefined값을 남기지만
splice 메서드를 사용시 배열의 길이까지 깔끔하게 제거 가능

### slice 문법
arr.slice([start], [end])
이 메서드는 "start" 인덱스부터 ("end"를 제외한) "end"인덱스까지의 요소를 복사한 새로운 배열을 반환합니다.

### concat 문법
arr.concat(arg1, arg2...)
기존 배열의 요소를 사용해 새로운 배열을 만들거나 기존 배열에 요소를 추가하고자 할 때 사용할 수 있습니다.

### forEach로 반복작업 하기
arr.forEach(function(item, index, array) {
  // 요소에 무언가를 할 수 있습니다.
});
주어진 함수를 배열 요소 각각에 대해 실행할 수 있게 해줍니다.

### indexOf, lastIndexOf와 includes
arr.indexOf(item, from)는 인덱스 from부터 시작해 item(요소)을 찾습니다. 요소를 발견하면 해당 요소의 인덱스를 반환하고, 발견하지 못했으면 -1을 반환합니다.
arr.lastIndexOf(item, from)는 위 메서드와 동일한 기능을 하는데, 검색을 끝에서부터 시작한다는 점만 다릅니다.
arr.includes(item, from)는 인덱스 from부터 시작해 item이 있는지를 검색하는데, 해당하는 요소를 발견하면 true를 반환합니다.

### find와 findIndex
let result = arr.find(function(item, index, array) {
  // true가 반환되면 반복이 멈추고 해당 요소를 반환합니다.
  // 조건에 해당하는 요소가 없으면 undefined를 반환합니다.
});
객체로 구성된 배열에서 특정 조건을 부합하는 객체를 찾을때 사용

### filter
let results = arr.filter(function(item, index, array) {
  // 조건을 충족하는 요소는 results에 순차적으로 더해집니다.
  // 조건을 충족하는 요소가 하나도 없으면 빈 배열이 반환됩니다.
});
filter는 find와 문법이 유사하지만, 조건에 맞는 요소 전체를 담은 배열을 반환한다는 점에서 차이가 있습니다.

## 배열을 변형하는 메서드

### map
let result = arr.map(function(item, index, array) {
  // 요소 대신 새로운 값을 반환합니다.
});
map은 배열 요소 전체를 대상으로 함수를 호출하고, 함수 호출 결과를 배열로 반환해줍니다.

### sort(fn)
arr.sort();
arr.sort()는 배열의 요소를 정렬해줍니다. 배열 자체가 변경됩니다.
요소는 문자열로 취급되어 재 정렬되는점 주의!

function compareNumeric(a, b) {
  if (a > b) return 1;
  if (a == b) return 0;
  if (a < b) return -1;
}

let arr = [ 1, 2, 15 ];

arr.sort(compareNumeric);

alert(arr);  // 1, 2, 15

등으로 사용 가능

### reverse
arr.reverse();
arr의 요소를 역순으로 정렬시켜주는 메서드입니다.

### split과 join























