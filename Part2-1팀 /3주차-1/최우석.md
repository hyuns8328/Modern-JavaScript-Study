> 생소한 개념 : ✨ / 추가 학습 필요한 개념 : ❓

# 배열과 메서드
## 요소 추가, 제거 메서드
> ### ✨ `splice()`
- `delete`를 사용해 배열의 요소를 지우면 값은 지워지지만 공간은 그대로 차지하고 있음.
  - 값도 지우고 그 값이 차지하고 있던 공간까지 지우려면 `splice()` 사용해야 함
- `splice()` ➡️ 배열의 요소 **추가, 삭제, 교체** 모두 가능
- 기본 형태
  ```javascript
  arr.splice(index[, deleteCount, elem1, ..., elemN])
  ```
  - 첫 번째 매개변수 &rarr; 조작을 가할 첫 번째 요소를 가리키는 `인덱스(index)`(음수도 가능)
  - 두 번째 매개변수 &rarr; 제거하고자 하는 요소의 개수
  - 세 번째 매개변수부터 &rarr; 배열에 추가할 요소
  - `splice` 활용 예제
    ```javascript
    let arr = ['apple', 'orange', 'grape'];

    let removeArr = arr.splice(0,1);
    console.log(removeArr);          // ['apple']

    arr.splice(1,1,'banana');
    console.log(arr);                // ['orange', 'banana']

    arr.splice(0,0,'kiwi');
    console.log(arr);                // ['kiwi', 'orange', 'banana']
    ```

> ### `slice()`
- 기본 형태
  ```javascript
  arr.slice([start], [end])
  ```
  - `start` 인덱스부터 `end - 1` 인덱스까지의 요소를 복사한 **새로운 배열**을 리턴
    - start와 end가 음수인 경우 배열 끝에서부터의 요소 개수를 의미
- 인수를 하나도 넘거지 않고 호출하면 arr의 복사본을 만들 수 있음
  - 기존의 배열을 건드리지 않고 새로운 배열을 만들 때 주로 사용

> ### ✨ `concat`
- 기본 형태
  ```javascript
  arr.concat(arg1, arg2...)
  ```
  - `arr`에 속한 요소와 작성한 인자에 속한 모든 요소를 모아 **새로운 배열**로 리턴
    - 작성한 인수가 배열인 경우 배열의 모든 요소가 복사되고 그렇지 않은 경우에는 인수가 그대로 복사
  - 활용 예제
    ```javascript
    let arr = [ a ];
    console.log(arr.concat([b, c, d]);  // a,b,c,d
    ```
- **객체**가 인자로 넘어오면 분해되지 않고 통으로 복사됨 (유사 배열 객체도 마찬가지!)
  - 유사 배열 객체에 `Symbol.isConcatSpreadable` 프로퍼티가 있으면 배열로 취급하게 되어 통으로 저장되는 것이 아닌 분해되어 저장됨

<br>

## 반복작업
> ### `forEach()`
- 기본 형태
  ```javascript
  arr.forEach(function(item, index, array) {
    // 요소에 할 작업 코드
  }
  ```
- 주어진 함수를 배열 요소 각각에 대해 실행

<br>

## 배열 탐색 메서드
> ### `indexOf()` / `lastIndexOf()` / `includes()`
- `arr.indexOf(item, from)`는 인덱스 from부터 시작해 item(요소) 탐색. 요소를 발견하면 해당 요소의 인덱스를 리턴. 발견하지 못했으면 -1 리턴
- `arr.lastIndexOf(item, from)`는 `indexOf`의 반대 버전. 끝에서부터 검색 시작
- `arr.includes(item, from)`는 인덱스 from부터 시작해 item이 있는지를 검색하고 발견하면 `true` 리턴 (존재여부만 체크)
  - ✨ 위 메서드들은 요소 탐색 시 `===`를 사용. (`false` 검색 시 `0`이 아닌 정확히 `false` 검색)

> ### `find()` / `findIndex()`
- 형태
  ```javascript
  // item(함수를 호출할 요소), index(요소의 인덱스), array(배열 자기 자신)
  let result = arr.find(function(item, index, array) {});
  ```
  - true가 리턴되면 반복 종료 후 해당 요소를 반환 (조건을 충족하는 요소 **단 하나** 찾음)
  - 조건에 해당하는 요소 없을 시 `undefined` 리턴
  - `findIndex()`는 `find()`와 같은 동작하지만 해당 요소 대신 인덱스를 리턴
    - 조건에 맞는 요소 없을 시 -1 리턴

> ### `filter()`
- 조건에 맞는 요소 전체를 담은 **배열을 리턴**
  ```javascript
  let results = arr.filter(function(item, index, array) {});
  ```
  - 조건을 충족하는 요소는 `results`에 순차적으로 더해짐
    - 조건을 충족하는 요소가 하나도 없으면 빈 배열 리턴


<br>

## 배열 변형 메서드
> ### `map()`
- 배열 요소 전체를 대상으로 함수를 호출하고 함수 호출 결과를 **새로운 배열**로 리턴
- 기본 형태
  ```javascript
  let result = arr.map(funciton(item, index, array) {});
  ```

> ### `sort()`
- 배열의 요소를 정렬. (**‼️원본 배열이 변경됨‼️**)
- ✨ 배열 안의 요소는 문자열로 취급되어 정렬됨 (유니코드 순으로 정렬이 진행되기 때문에 예상과 다르게 정렬될 수 있음)
  - ✨ 배열 안의 요소들을 정렬하는 기준을 정해주는 함수를 넘겨주면 예상대로 정렬됨 ➡️ **정렬 함수(ordering function)**
    - ✨ 정렬 함수의 리턴값에는 제약이 없음. 두 인수를 비교해서 큰지 작은지만 나타내면 됨

> ### `reverse()`
- `arr`의 요소를 역순으로 정렬 (**원본 배열이 변경됨**)

> ### `split()` / `join()`
- `split(구분자)`는 구분자를 기준으로 문자열을 쪼개줌
  ```javascript
  let users = 'John, Park, Lee';
  let arr = user.split(',');

  for(let user of arr) {console.log(`${user}이 입장하셨습니다.`};
  ```
  - `split()`은 두 번째 인수로 **배열의 길이**를 받음. (이 배열의 길이를 넘어서는 요소는 무시)
  - `split()`의 인수를 빈 문자열 `''`로 지정하면 문자열을 글자 단위로 분리
- `join()`은 `split()`과 반대 역할. 배열의 요소를 인수를 붙여 모두 합쳐 하나의 문자열로 리턴
  ```javascript
  let users = 'John, Park, Lee';
  let arr = user.join(',');

  console.log(arr); //John,Park,Lee;
  ```

> ### ✨❓ `reduce()` / `reduceRight()`
- 배열 내 요소를 대상으로 반복 작업하면서 값 하나를 도출할 때 사용
- 형태
  ```javascript
  let value = arr.reduce(function(accumulator, item, index, array) {
  // ... }, [initial]);
  ```
  - `accumulator` : 이전 함수 호출의 결과. `initial`은 함수 최초 호출 시 사용되는 초깃값(옵션)
  - `item` : 현재 배열 요소
  - `index` : 요소의 위치
  - `array` : 배열
- 인수로 넘겨주는 함수는 배열의 모든 요소를 대상으로 차례차례 적용, 적용 결과는 다음 함수 호출 시 사용
  - ✨ **이전 함수 호출 결과 -> 다음 함수 호출할 때의 첫 번째 인수로 사용됨**
  - 첫 번째 인수 ➡️ 앞서 호출했던 함수들의 결과가 누적되어 저장되는 '**누산기(accumulator)**'
    - 마지막 함수까지 호출되면 이 값은 `reduce`의 리턴값이 됨
  ```javascript
  let arr = [1, 2, 3, 4, 5];
  let result = arr.reduce((sum, current) => sum + current, 0);

  console.log(result); // 15
  ```
  - 위 예제코드 흐름 설명
    1. 함수 최초 호출 시, `reduce`의 마지막 인수인 `0(초깃값)`이 `sum`에 할당. `current`에는 배열의 첫 번째 요소 `1` 할당. 함수의 결과가 `1`이 됨
    2. 두 번째 호출 시, `sum = 1`이고 여기에 `2`가 더해지므로 결과는 `3`
    3. 세 번째 호출 시, `sum = 3`이고 그 다음 배열의 요소가 더해짐.
    4. 위의 과정 반복
- `reduce`의 초깃값을 작성하지 않으면 **배열의 첫 번째 요소를 초깃값으로 사용**
  - if) 배열이 비어있는 상태라면 초기값이 없이 `reduce` 호출 시 에러 발생
- `reduceRight()`는 `reduce`와 동일한 기능. **But, 배열의 오른쪽부터 연산 수행**

<br>

## 배열 여부 판단
> ### `Array.isArray`
- `Array.isArray(value)`에서 `value`가 배열이라면 `true`, 아니라면 `false` 리턴

<br>

## ✨❓ 배열 메서드와 `thisArg`
- `sort()`를 제외한 대부분의 배열 메서드에 선택적으로 사용할 수 있는 마지막 인수
```javascript
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
```
- `thisArg`는 `func`의 `this`가 됨
