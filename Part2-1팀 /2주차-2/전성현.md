## 참조에 의한 객체 복사

원시값(문자열, 숫자, 불린 값)은 값 그대로 저장·할당·복사됨
```js
let message = "Hello!";
let phrase = message;
```
객체는 객체 그대로 저장되는 것이 아니라 객체가 저장된 '메모리 주소’인 객체에 대한 '참조 값’이 저장·복사됨
```js
let user = { name: "John" };

let admin = user;  // 참조값을 복사
```
### 객체 복사·병합과 Object.assign

객체를 복제하고 싶다면?
1. `for ... in` 반복문 사용
```js
let user = {
  name: "John",
  age: 30
};

let clone = {};  // 새로운 빈 객체

// 빈 객체에 user 프로퍼티 전부를 복사해 넣음
for (let key in user) {
  clone[key] = user[key];
}

clone.name = "Pete";  // clone의 데이터를 변경

alert( user.name );  // 기존 객체에는 여전히 John이 있음
```
2. `Object.assign()` 사용 (얕은 복사)
```js
let user = {
  name: "John",
  age: 30
};

let clone = Object.assign({}, user);
console.log(user);  // { name: 'John', age: 30 }
```
⚠️ 주의할 점: 중첩 객체는 복사가 불가능

### 깊은 복사
복사본의 속성이 원본 객체와 같은 참조를 공유하지 않는 복사
복사본에 어떠한 변경이 있어도 원본 객체에 영향을 주지 않음
프로퍼티가 객체인 경우, 객체의 구조도 복사함
자바스크립트 라이브러리 lodash의 메서드인 `_.cloneDeep(obj)`을 사용

### Object.assign()
```js
Object.assign(dest, [src1, src2, src3, ..., srcN])
```
첫 번째 파라미터 `dest`
: 목표 객체
두 번째 파라미터 `[src1, src2, src3, ..., srcN]`
: 복사할 객체이고, 개수 제한이 없어 필요에 따라 많은 객체를 파라미터로 사용이 가능함
객체 `[src1, src2, ..., srcN]`의 프로퍼티를 `dest`에 복사하고, `dest`를 반환함
assign 메서드를 사용하여 여러 객체를 하나로 병합할 수 있음
목표 객체에 동일한 이름을 가진 프로퍼티가 있는 경우에는 기존 값을 덮어씌움(할당)

## 옵셔널 체이닝 '?.'

옵셔널 체이닝을 사용하면 프로퍼티가 없는 중첩 객체를 에러 없이 안전하게 접근이 가능함

### 옵셔널 체이닝이 필요한 이유
주소 정보가 없는 사용자의 정보에 접근하면 에러가 발생
페이지에 존재하지 않는 요소에 접근해 정보를 가져올 때 에러가 발생
옵셔널 체이닝이 등장하기 전에는 `&&` 연산자를 통해 문제를 해결했는데, 코드가 길어진다는 단점이 존재함

### 옵셔널 체이닝의 등장
옵셔널 체이닝은 `?.` 앞의 평가 대상이 `undefined`나 `null`이면 평가를 멈추고 `undefined`를 반환함
```js
let user = {};  // 주소 정보가 없는 사용자

alert( user?.address?.street );  // undefined, 에러가 발생하지 않음
```
`user?.address`로 주소를 읽으면 아래와 같이 `user` 객체가 존재하지 않더라도 에러가 발생하지 않음
```js
let user = null;

alert( user?.address );         // undefined
alert( user?.address.street );  // undefined
```
위에서 사용된 `user?.`은 `user`가 `null`이나 `undefined`인 경우만 처리가 가능
`user`의 실제 값이 존재하는 경우에는 `user.address` 프로퍼티는 있어야 함
그렇지 않으면 `user?.address.street`의 두 번째 점 연산자에서 에러가 발생

### ⚠️ 옵셔널 체이닝 사용 시 주의사항
1. 옵셔널 체이닝을 남용하지 말기
2. `?.` 앞의 변수는 반드시 선언하기

### 단락평가
`?.`의 왼쪽 평가대상에 값이 없으면 즉시 평가를 멈춤
그래서 함수 호출과 `?.` 오른쪽에 코드가 있더라도 동작하지 않음
```js
let user = null;
let x = 0;

user?.sayHi(x++);  // 아무 일도 일어나지 않음

alert(x);  // 0, x는 증가하지 않음
```
