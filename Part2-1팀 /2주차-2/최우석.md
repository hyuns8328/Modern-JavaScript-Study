> 생소한 개념은 ✨로 표시

## 참조에 의한 객체 복사
- 객체와 원시 타입 사이에 가장 두드러지게 차이를 보이는 부분은 복사를 할 때 나타남 ➡️ 객체는 **참조에 의해** 저장되고 복사
  > **원시값** -> 변수에 **값이 그대로** 저장,할당,복사
    ```javascript
    // 원시값의 복사. age, cloneAge에는 각각 20이라는 값이 독립적으로 저장됨
    let age = 20;
    let cloneAge = age;
    ```
  > **객체** -> 변수에 **객체가 저장되어 있는 참조값(주소값)** 이 저장됨
    ```javascript
    let obj = {
      age: 20
    };
    let cloneObj = obj;  // obj의 주소값을 cloneObj에 할당. 두 변수는 모두 같은 객체에 대한 참조값이 저장됨
    cloneObj.age = 25;
    console.log(obj.age);  // 25가 출력됨
    ```
- 참조에 의한 복사를 한 두 객체는 비교 시 `===`, `==`가 동일하게 동작
  ```javascript
  let obj1 = {};
  let obj2 = obj1;    // 참조에 의한 복사 실시

  console.log( obj1 == obj2 );    // true
  console.log( obj1 === obj2 );   // true
  ```
  - ✨ 헷갈릴 수 있는 예제
    ```javascript
    let obj1 = {};
    let obj2 = {};

    console.log( obj1 == obj2 );  // obj1과 obj2는 독립된 두 객체이기 때문에 false 출력
    ```
- #### ✨ `Object.assign()`
  - 출처 객체들의 모든 열거 가능한 자체 속성을 복사해 대상 객체에 붙여넣는 메서드 ( [출처 : MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Object/assign) )
  - 형태
    ```javascript
    Object.assign(targetObj, [복사하고자 하는 객체1, 복사하고자 하는 객체2, 복사하고자 하는 객체3...])
    ```
  > 활용 예제
  ```javascript
  let user = {
  name: "John",
  age: 30
  };

  //user에 있는 모든 프로퍼티가 빈 배열에 복사됨. 만약 동일한 이름을 가진 프로퍼티가 존재할 경우 기존 값에 덮어씀
  let clone = Object.assign({}, user);  
  ```
  - **✨ 만약 프로퍼티가 원시값이 아닌 객체라면?!**
    - 위의 활용 예제 같은 코드를 작성해도 복제할 수 없음 ➡️ **중첩된 객체의 주소값이 복사**되기 때문!
    - 이 때는 **깊은 복사(deep cloning)** 를 해야함
      - ✨ 깊은 복사에 사용되는 표준 알고리즘 -> `Structured cloning algorithm`

<br>

## ✨ 옵셔널 체이닝 `?.`
- 자바스크립트를 사용해 존재하지 않는 요소에 접근할 경우 문제 발생
- 옵셔널 체이닝이 생기기 전에는 `&&`를 사용했음 ➡️ 코드가 길어진다는 단점🥲
  ```javascript
  let user = {};

  console.log( user.address.street );  // TypeError
  console.log( user && user.address && user.address.street );  // undefined
  ```
- ✨ 옵셔널 체이닝은 `?.` 앞의 평가 대상이 `undefined`이거나 `null`이면 평가를 멈추고 `undefined` 리턴
  ```javascript
  let user1 = {};
  console.log( user1?.address?.street ); // 에러가 발생하지 않고 undefined 출력

  let user2 = null;
  console.log( user2?.address ); // undefined
  console.log( user2?.address.street ); // undefined
  ```
  > 코드 흐름 설명 (user1의 경우)
    1. user1은 빈 객체. `null`이나 `undefined`가 아니라서 평가 계속 진행
    2. user1.address를 확인하려고 하는데 address라는 프로퍼티 존재하지 않음 -> `undefined`
    3. undefined?.street를 평가해야하는데 `?.`앞의 값이 `undefined`이므로 더 이상 평가하지 않고 `undefined` 리턴
  > 코드 흐름 설명 (user2의 경우)
    1. 이미 user2가 `null`이기 때문에 null?.address를 평가할 시점에 undefined로 확정
    2. console.log 하는 두 코드 모두 같은 방식으로 동작
- ✨ 옵셔널 체이닝은 **존재하지 않아도 괜찮은 대상**에만 사용해야 함
- ✨ 옵셔널 체이닝 앞의 변수는 **꼭 선언되어 있어야 함**
  - `?.` 앞의 변수가 선언되어 있지 않다면 코드 평가 시점에 에러 발생 (`ReferenceError`)
- ✨ `?.`는 왼쪽 평가 대상에 값이 없으면 즉시 평가를 멈춤 ➡️ **단락 평가(short-circuit)**
  - ✨ 따라서 `?.`의 평가가 멈췄을 때 `?.` 오른쪽에 있는 코드는 실행이 안된다
- `?.`은 연산자가 아닌 함수/대괄호와 함께 동작하는 **문법 구조체**
  - `?.()`나 `?.[]`를 사용하여 **객체의 존재 여부가 확실하지 않은 경우**에도 안전하게 프로퍼티 읽기 가능
  - ✨ `?.`는 **읽기 전용 문법**.
    - 할당 연산자 `=` 왼쪽에는 옵셔널 체이닝을 사용할 수 없음 ➡️ 좌항의 객체가 정상적이든 아니든 상관없이 항상 `SyntaxError`
